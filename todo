TODO:
- change .root entries so that finding the list of .node entries is easier
- cache .node and .data entries for path
- figure out what operation is primary bottleneck



 -- remove zip archives for good, by modifying readdir!

- add modified time for INDIVIDUAL BLOCKS
- there are instances where people work on different blocks,
and currently only the later write will get noticed!

- when a new .root is made for a file with previous .root entries, copy those over to the new .root!
Issue:
- cache consistency when garbage collection occurs
solution: implement function in block_cache to "update" its file cache
when gc occurs, if gc is implemented in fuse_ops. Alternatively,
gc should be implemented in the block_cache

===
New design
- each .root file contains the path, inode id, and a [list-of (.node, offset, sizeof ent)]
- each .node file contains path, mode, links, mtime, ctime, size, deleted and a [list of (block#, offset into data, size of block)]
- each .data file contains the file data, which is retrieved with the information in the .node files

TODO:
 - make looking for a particular inode id / path faster than linear time, using a tree like structure
===

- add blocks to block map


- normalize block cache map
- move away from meta_data_ into multiple maps
    - data is separated to make loading / flushing easier
- add a map for .node file contents

- store written blocks for flushing, avoid copying redundant blocks!


Initial Plan for data format (simulate zip archives, but without the zipping!!)
- so by flushing the map, 2 files are created: .head and .node
- the .head and .node files are named the same, and a .head file contains the offset# and size for inode information within the .node files
(.head is == to .idx and .node == .zip)
- each .node file contains the information for the flushed inodes: inode stat info, block#s, offsets into .data files
- each .data file contains file data. .node files contain indexes into the .data files

Issue:
- putting together a file with blocks spread across .node files

solution: maintain .root files which contain records (inode#, [list of .head files])

Issue:
- finding latest version of a file
solution: check timestamps of each root file, take the latest one

Issue:
- finding old info for an inode in new root
solution: copy old info over, append new .head file

Issue:
- finding block data in a .node file efficiently
solution: create a .data file containing the block data for the inode,
            .node files contain a table of offsets into the .data file. Constant time yo

Issue:
- finding latest version of a block
solution: time stamp each header file. Put the list of blocks the inode has in the header file.
- when looking for a particular block, scan the .root file, then scan each .header file.

What this should look like:
[list-of root], root is [list of (inode#, list of .head)]
and a [list of .head + (.node, .data)]

searching for a file is pretty slow, but moving from this to a tree shouldn't be that bad. Roots can be cached

- remove garbage collection for now

====

Snapshots

TODO!!
